<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="CSS\code_body.css">
    <link rel="stylesheet" href="CSS\header-footer.css">
    <title>Circular Queue</title>
    <style>
        #circularQ_img{
            margin-left: 20%;
        }
    </style>
</head>

<body>
    <!-- HEADER STARTS -->
    <header>
        <a id="top"></a>

        <div id="topheader">

            <div id="logo">
                <img src="img/logo.png" alt="Logo" width="150px">
            </div>

            <div class="chaosencoded">
                <p>
                    <a href="index.html">
                        <h1>Chaos <br> &lt; &#8725; Encoded &gt;</h1>
                    </a>
                </p>
            </div>

        </div>

        <nav class="nav-bar">

            <a href="index.html">Home</a>
            <a href="AboutUs.html">About Us</a>
            <a href="ContactUs.html">Contact Us</a>

        </nav>

    </header>
    <!-- HEADER ENDS -->



    <!-- BODY STARTS -->

    <main>
        <h1 class="main_head"> Circular Queue Implementation  </h1>
        <div id="main_content">
            <p class="code_description">
                A Circular Queue in C is a data structure in which elements are stored in a circular manner. In Circular Queue, after the last element, the first element occurs.
            </p>
            <p class="code_description">
                A Circular Queue is used to overcome the limitation we face in the array implementation of a Queue. The problem is that when the rear reaches the end and if we delete some elements from the front and then try to add a new element in the queue, it says <b>"Queue is full"</b>, but still there are spaces available in the queue.
            </p>
            <img  id="circularQ_img" src="img\circular-queue.png" alt="circular queue need" width="450">
            <p class="code_description">
                As we can see in the above image, the rear is at the last position of the Queue and front is pointing somewhere rather than the 0th position. In the above array, there are only two elements and other three positions are empty. The rear is at the last position of the Queue; if we try to insert the element then it will show that there are no empty spaces in the Queue. There is one solution to avoid such wastage of memory space by shifting both the elements at the left and adjust the front and rear end accordingly. It is not a practically good approach because shifting all the elements will consume lots of time. The efficient approach to avoid the wastage of the memory is to use the circular queue data structure.
            </p>
            </p>
            <h3 class= "algo_subheads">Operations associated with a circular queue in C :</h3>
            <ul class="code_description" type="circle">
                <li><b>isEmpty()</b>: To check if the queue is empty</li>
                <li><b>isFull()</b>: To check whether the queue is full or not</li>
                <li><b>dequeue()</b>: Removes the element from the frontal side of the circular queue.  In a circular queue, the element is always deleted from front position. 
                    <ol type="i">
                        <li>Check whether queue is Full - Check <b>((rear == SIZE-1 && front == 0) || (rear == front-1))</b>.</li>
                        <li>If it is full then display Queue is full. If queue is not full then, check if <b>(rear == SIZE - 1 && front != 0)</b> if it is true then set <b>rear=0</b> and insert element.</li>
                    </ol>
                </li>
                <li><b>enqueue()</b>: It inserts elements to the end of the circular queue. In a circular queue, the new element is always inserted at Rear position.
                    <ol type="i">
                        <li>Check whether queue is Empty means check <b>(front==-1)</b>.</li>
                        <li>If it is empty then display Queue is empty. If queue is not empty then step 3.</li>
                        <li>Check if <b>(front==rear)</b> if it is true then set <b>front=rear= -1</b> else check if <b>(front==size-1)</b>, if it is true then set <b>front=0</b> and return the element.</li>
                    </ol>
                </li>
                <li><b>Front</b>: Pointer element responsible for fetching the first element from the queue.</li>
                <li><b>Rear</b>: Pointer element responsible for fetching the last element from the queue.</li>
            </ul>
            <h2 class="headings">Algorithm</h2>
            <p class= "algo_subheads">Queue follows the First-In-First-Out pattern. The first element is the first to be pulled out from the list of elements.</p>
            <ul class="code_description" type="disc">
                <li><b>Front</b> and <b>Rear</b> pointers keep the record of the first and last element in the queue.</li>
                <li>At first, we need to initialize the queue by setting <b>Front = -1</b> and <b>Rear = -1</b></li>
                <li>In order to insert the element (enqueue), we need to check whether the queue is already full i.e. <b>check the condition for Overflow</b>. If the queue is not full, we'll have to increment the value of the Rear index by <b>1</b> and place the element at the position of the Rear pointer variable. When we get to insert the first element in the queue, we need to set the value of Front to <b>0</b>.</li>
                <li>In order to remove the element (<b>dequeue</b>) from the queue, we need to check whether the queue is already empty i.e. <b>check the condition for Underflow</b>. If the queue is not empty, we'll have to remove and return the element at the position of the Front pointer, and then increment the Front index value by 1. When we get <b>to remove the last element from the queue</b>, we will have to <b>set the values of the Front and Rear index to -1</b>.
                </li>
            </ul><br>
            <p class="code_description"> The most common queue implementation is using arrays, but it can also be implemented using lists.. Below here we have implemented queues using arrays in C.</p>
            <h2 class="headings">Program using C</h2>
            <!-- CODE BOX -->
<textarea id="HTMLBox" readonly style="font-size:15px; height:700px;width:800px;border:1px solid; overflow:scroll;
background-color:rgb(237, 237, 237); color:rgb(0, 0, 0);
scrollbar-base-color:rgb(190, 188, 178);font-family:Consolas;" >
//CIRCULAR QUEUE MENU DRIVEN
#include<stdio.h>
#include<stdlib.h>
#define MAX 20
void CQinsert(int[], int);
int CQdelete(int []);
int CQdisplay(int []);
int front = -1, rear = -1;
int main()
{
	int ch,x,CQ[MAX],item;
	while(1)
	{
		printf("\n --- CIRCULAR QUEUE MENU --- \n 1. Insert\n 2. Delete\n 3. Display\n 4. Exit\n\n Enter your choice:- ");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:
				printf("\nEnter the element to be inserted:- ");
				scanf("%d",&x);
				CQinsert(CQ,x);
				break;
			case 2: 
				item = CQdelete(CQ);
				if(item!=-1)
					printf("\nThe deleted item is: %d\n",item)	;
				break;
			case 3:
				CQdisplay(CQ);
				break;
			case 4: exit(0);
			default: 
				printf("\nInvalid Choice.\n");		
		}
	}
}

void CQinsert(int CQ[], int x)
{
    if(front == (rear+1)%MAX)
    {
        printf("\nOverflow - Queue is full.\n");
        exit;
    }
    else if(front == -1)
        front = rear = 0;
    else
        rear = (rear+1)%MAX;
        CQ[rear] = x;
}

int CQdelete(int CQ[])
{
    int x;
    if(front == -1)
    {
        printf("\nUnderflow - Queue is empty.\n");
        return(-1);
    }
    else
    {
        x = CQ[front];
        if(front == rear)
            front = rear = -1;
        else
            front = (front +1)%MAX;
            return x;        
    }
}

int CQdisplay(int CQ[])
{
    int i;
    if(front == -1)
        printf("\nUnderflow - Queue is empty.\n");
    else
        {
            if(front <= rear)
            {
                for(i = front; i<= rear; i++)
                printf("%d\t",CQ[i]);
        	}
            else
       		{
                for(i=front; i< MAX; i++)
                printf("%d\t",CQ[i]);
                for(i=0; i<= rear; i++)
                printf("%d\t",CQ[i]);
            }
        }
}
                  </textarea>
                  
                  <button id="CopyButton"><img src="img\copy.png" alt="" width="25px"></button>
                  <script>
                      // HTML BOx JS Code
                      let HTMLBox = document.getElementById("HTMLBox");
                      let CopyButton = document.getElementById("CopyButton");
      
                      CopyButton.onclick = function () {
                          HTMLBox.select();
                          document.execCommand("copy");
                          // HTMLButton.innerImg = "Codes Copied"
                      }
                  </script>
                  </div>
              </main>
                  <!-- BODY ENDS -->

            
            <!-- FOOTER STARTS -->
            <footer>
                <div class="footer">
        
                    <div class="first-content">
                        <h3><a href="AboutUs.html">About Us</a></h3>
                        <p>
                            At <strong>ChaosEncoded</strong> we believe that once in a while each one of us needs a helping hand.
                            Delivering some kind of relief in the form of solutions to your problems, makes us happy. 
                            We will be delighted if our users consider us to be their first choice, whenever they need
                            a solution regarding Data Structure using C programming language.
                        </p>
                    </div>
        
                    <div class="middle-content">
                        <a href="terms.html" style="margin: 5px;">Terms</a><br>
        
                        <a href="privacy.html" style="line-height:50px; margin: 5px;">Privacy Policy</a><br>
        
                        <img src="img/email_icon.png" alt="img" width="30px" style="float: left;clear: both;"><a
                            href="mailto:chaosencoded@gmail.com" style="float: left;line-height: 18px;
                        padding: 5px;">chaosencoded@gmail.com</a>
        
                        <img src="img/phone_icon.png" alt="img" width="20px"
                            style="float: left;clear: both;margin-top: 30px;margin-left: 2px;"><a href="tel:+916234673424"
                            style="float: left;margin-top: 30px;padding: 5px;">+91 6234673424</a>
        
                    </div>
                    <div class="follow-us">
                        <h3>Follow Us</h3>
        
                        <div class="icon">
                            <a href="#" target="_blank"><img src="img/fb_icon.png" alt="img" width="30px"></a>
                        </div>
        
                        <div class="icon">
                            <a href="#" target="_blank"><img src="img/insta_icon.png" alt="img" width="30px"></a>
                        </div>
        
                        <div class="icon">
                            <a href="#" target="_blank"><img src="img/github_icon.png" alt="img" width="30px"></a>
                        </div>
        
                        <div class="icon">
                            <a href="#" target="_blank"><img src="img/twitter_icon.png" alt="img" width="30px"></a>
                        </div>
        
                    </div>
        
                    <div class="lower-footer">
                        <p>@Copyright 2022 - ChaosEncoded. All rights reserved.</p>
                    </div>
        
                </div>
            </footer>
            <!-- FOOTER ENDS -->
</body>

</html>
